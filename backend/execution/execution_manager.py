"""
–ò—Å–ø—Ä–∞–≤–ª–µ–Ω–Ω—ã–π ExecutionManager —Å –ø–æ–ª–Ω–æ–π –∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏–µ–π open_position/close_position.

–ö–õ–Æ–ß–ï–í–´–ï –ò–°–ü–†–ê–í–õ–ï–ù–ò–Ø:
1. –ü–æ–ª—É—á–µ–Ω–∏–µ —Ä–µ–∞–ª—å–Ω–æ–≥–æ –±–∞–ª–∞–Ω—Å–∞ —á–µ—Ä–µ–∑ balance_tracker
2. –ü—Ä–∞–≤–∏–ª—å–Ω–æ–µ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ —Ç—Ä–∏–≥–≥–µ—Ä–æ–≤ PositionStateMachine
3. _execute_signal –∏–Ω—Ç–µ–≥—Ä–∏—Ä–æ–≤–∞–Ω —Å open_position
"""

import asyncio
from typing import Optional, Dict, List
from collections import deque

from core.logger import get_logger
from core.exceptions import ExecutionError, OrderExecutionError
from core.trace_context import trace_operation
from database.models import AuditAction, OrderStatus, PositionStatus
from domain.services.fsm_registry import fsm_registry
from domain.services.idempotency_service import idempotency_service
from domain.state_machines.order_fsm import OrderStateMachine
from domain.state_machines.position_fsm import PositionStateMachine
from infrastructure.repositories.audit_repository import audit_repository
from infrastructure.repositories.order_repository import order_repository
from infrastructure.repositories.position_repository import position_repository
from infrastructure.resilience.circuit_breaker import circuit_breaker_manager
from infrastructure.resilience.rate_limiter import rate_limited
from models.signal import TradingSignal, SignalType
from models.market_data import OrderSide, OrderType, TimeInForce
from exchange.rest_client import rest_client
from strategy.risk_manager import RiskManager
from strategy.signal_deduplicator import signal_deduplicator
from utils.balance_tracker import balance_tracker  # –ò–ú–ü–û–†–¢ balance_tracker
from utils.helpers import get_timestamp_ms, round_price, round_quantity

logger = get_logger(__name__)


class ExecutionManager:
    """–ú–µ–Ω–µ–¥–∂–µ—Ä –∏—Å–ø–æ–ª–Ω–µ–Ω–∏—è —Ç–æ—Ä–≥–æ–≤—ã—Ö –æ—Ä–¥–µ—Ä–æ–≤ —Å –ø–æ–ª–Ω—ã–º —É–ø—Ä–∞–≤–ª–µ–Ω–∏–µ–º –ø–æ–∑–∏—Ü–∏—è–º–∏."""

    def __init__(self, risk_manager: RiskManager):
        """
        –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –º–µ–Ω–µ–¥–∂–µ—Ä–∞ –∏—Å–ø–æ–ª–Ω–µ–Ω–∏—è.

        Args:
            risk_manager: –ú–µ–Ω–µ–¥–∂–µ—Ä —Ä–∏—Å–∫–æ–≤
        """
        self.risk_manager = risk_manager
        self.rest_client = rest_client

        # –û—á–µ—Ä–µ–¥—å —Å–∏–≥–Ω–∞–ª–æ–≤ –¥–ª—è –∏—Å–ø–æ–ª–Ω–µ–Ω–∏—è
        self.signal_queue: asyncio.Queue = asyncio.Queue()

        # –ò—Å—Ç–æ—Ä–∏—è –∏—Å–ø–æ–ª–Ω–µ–Ω–∏—è
        self.execution_history: deque = deque(maxlen=1000)

        # –§–ª–∞–≥ —Ä–∞–±–æ—Ç—ã
        self.is_running = False
        self.execution_task: Optional[asyncio.Task] = None

        # –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞
        self.stats = {
            "total_signals": 0,
            "executed_orders": 0,
            "rejected_orders": 0,
            "failed_orders": 0,
        }

        # Circuit breakers –¥–ª—è API
        self.order_breaker = circuit_breaker_manager.get_breaker(
            name="order_placement",
            failure_threshold=5,
            cooldown_seconds=60
        )

        logger.info("ExecutionManager –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω —Å –ø–æ–ª–Ω–æ–π –∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏–µ–π –ø–æ–∑–∏—Ü–∏–π")

    # ==================== –ü–£–ë–õ–ò–ß–ù–´–ï –ú–ï–¢–û–î–´ ====================

    async def start(self):
        """–ó–∞–ø—É—Å–∫ –º–µ–Ω–µ–¥–∂–µ—Ä–∞ –∏—Å–ø–æ–ª–Ω–µ–Ω–∏—è."""
        if self.is_running:
            logger.warning("–ú–µ–Ω–µ–¥–∂–µ—Ä –∏—Å–ø–æ–ª–Ω–µ–Ω–∏—è —É–∂–µ –∑–∞–ø—É—â–µ–Ω")
            return

        self.is_running = True
        logger.info("–ó–∞–ø—É—Å–∫ –º–µ–Ω–µ–¥–∂–µ—Ä–∞ –∏—Å–ø–æ–ª–Ω–µ–Ω–∏—è")

        # –ó–∞–ø—É—Å–∫–∞–µ–º –∑–∞–¥–∞—á—É –æ–±—Ä–∞–±–æ—Ç–∫–∏ –æ—á–µ—Ä–µ–¥–∏
        self.execution_task = asyncio.create_task(self._process_queue())

    async def stop(self):
        """–û—Å—Ç–∞–Ω–æ–≤–∫–∞ –º–µ–Ω–µ–¥–∂–µ—Ä–∞ –∏—Å–ø–æ–ª–Ω–µ–Ω–∏—è."""
        if not self.is_running:
            logger.warning("–ú–µ–Ω–µ–¥–∂–µ—Ä –∏—Å–ø–æ–ª–Ω–µ–Ω–∏—è —É–∂–µ –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω")
            return

        logger.info("–û—Å—Ç–∞–Ω–æ–≤–∫–∞ –º–µ–Ω–µ–¥–∂–µ—Ä–∞ –∏—Å–ø–æ–ª–Ω–µ–Ω–∏—è")
        self.is_running = False

        # –û—Ç–º–µ–Ω—è–µ–º –∑–∞–¥–∞—á—É –æ–±—Ä–∞–±–æ—Ç–∫–∏
        if self.execution_task and not self.execution_task.done():
            self.execution_task.cancel()
            try:
                await self.execution_task
            except asyncio.CancelledError:
                pass

    async def submit_signal(self, signal: TradingSignal):
        """
        –û—Ç–ø—Ä–∞–≤–∫–∞ —Å–∏–≥–Ω–∞–ª–∞ –Ω–∞ –∏—Å–ø–æ–ª–Ω–µ–Ω–∏–µ.

        Args:
            signal: –¢–æ—Ä–≥–æ–≤—ã–π —Å–∏–≥–Ω–∞–ª
        """
        await self.signal_queue.put(signal)
        self.stats["total_signals"] += 1
        logger.debug(f"{signal.symbol} | –°–∏–≥–Ω–∞–ª –¥–æ–±–∞–≤–ª–µ–Ω –≤ –æ—á–µ—Ä–µ–¥—å –∏—Å–ø–æ–ª–Ω–µ–Ω–∏—è")

    # ==================== –£–ü–†–ê–í–õ–ï–ù–ò–ï –ü–û–ó–ò–¶–ò–Ø–ú–ò ====================

    async def open_position(
        self,
        symbol: str,
        side: str,  # "Buy" –∏–ª–∏ "Sell"
        entry_price: float,
        quantity: float,
        stop_loss: Optional[float] = None,
        take_profit: Optional[float] = None,
        entry_signal: Optional[dict] = None,
        entry_market_data: Optional[dict] = None,
        entry_indicators: Optional[dict] = None,
        entry_reason: Optional[str] = None,
    ) -> Optional[dict]:
        """
        –û—Ç–∫—Ä—ã—Ç–∏–µ –ø–æ–∑–∏—Ü–∏–∏ —Å –†–ï–ê–õ–¨–ù–´–ú —Ä–∞–∑–º–µ—â–µ–Ω–∏–µ–º –æ—Ä–¥–µ—Ä–∞ –Ω–∞ Bybit.

        –ö–†–ò–¢–ò–ß–ï–°–ö–ò–ï –ò–ó–ú–ï–ù–ï–ù–ò–Ø:
        1. –û—Ä–¥–µ—Ä —Ä–∞–∑–º–µ—â–∞–µ—Ç—Å—è –Ω–∞ –±–∏—Ä–∂–µ –ü–ï–†–í–´–ú —à–∞–≥–æ–º
        2. –¢–æ–ª—å–∫–æ –ø–æ—Å–ª–µ —É—Å–ø–µ—à–Ω–æ–≥–æ —Ä–∞–∑–º–µ—â–µ–Ω–∏—è —Å–æ–∑–¥–∞—ë—Ç—Å—è –∑–∞–ø–∏—Å—å –≤ –ë–î
        3. Exchange order_id —Å–æ—Ö—Ä–∞–Ω—è–µ—Ç—Å—è –≤ metadata
        4. Rollback –ø—Ä–∏ –æ—à–∏–±–∫–µ
        """
        with trace_operation("open_position", symbol=symbol, side=side):
            logger.info(
                f"‚Üí –û—Ç–∫—Ä—ã—Ç–∏–µ –ø–æ–∑–∏—Ü–∏–∏: {symbol} {side} | "
                f"–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ: {quantity} @ {entry_price}"
            )

            position_id = None
            exchange_order_id = None

            try:
                # ==========================================
                # –®–ê–ì 0: –ì–ï–ù–ï–†–ê–¶–ò–Ø CLIENT ORDER ID
                # ==========================================
                client_order_id = idempotency_service.generate_idempotency_key(
                    operation="place_order",
                    params={
                        "symbol": symbol,
                        "side": side,
                        "quantity": quantity,
                        "timestamp": get_timestamp_ms()
                    }
                )

                # –ü—Ä–æ–≤–µ—Ä–∫–∞ –∏–¥–µ–º–ø–æ—Ç–µ–Ω—Ç–Ω–æ—Å—Ç–∏
                existing_result = await idempotency_service.check_idempotency(
                    operation="place_order",
                    params={"symbol": symbol, "side": side, "quantity": quantity}
                )

                if existing_result:
                    logger.warning(
                        f"‚ö†Ô∏è –û–±–Ω–∞—Ä—É–∂–µ–Ω –¥—É–±–ª–∏–∫–∞—Ç –æ–ø–µ—Ä–∞—Ü–∏–∏: {symbol} {side}"
                    )
                    return existing_result

                # ==========================================
                # –®–ê–ì 1: –†–ê–ó–ú–ï–©–ï–ù–ò–ï –û–†–î–ï–†–ê –ù–ê BYBIT
                # ==========================================
                logger.info(
                    f"üì§ –†–∞–∑–º–µ—â–µ–Ω–∏–µ MARKET –æ—Ä–¥–µ—Ä–∞ –Ω–∞ Bybit: {symbol} {side} {quantity}"
                )

                try:
                    # –ö–†–ò–¢–ò–ß–ï–°–ö–ò–ô –í–´–ó–û–í –ö BYBIT API
                    bybit_response = await self.rest_client.place_order(
                        symbol=symbol,
                        side=side,
                        order_type="Market",
                        quantity=quantity,
                        price=None,  # Market order
                        time_in_force="GTC",
                        stop_loss=stop_loss,
                        take_profit=take_profit,
                        client_order_id=client_order_id
                    )

                    # –ò–∑–≤–ª–µ—á–µ–Ω–∏–µ –¥–∞–Ω–Ω—ã—Ö
                    result_data = bybit_response.get("result", {})
                    exchange_order_id = result_data.get("orderId")
                    order_link_id = result_data.get("orderLinkId")

                    if not exchange_order_id:
                        raise OrderExecutionError(
                            f"Bybit –Ω–µ –≤–µ—Ä–Ω—É–ª orderId: {bybit_response}"
                        )

                    logger.info(
                        f"‚úÖ –û—Ä–¥–µ—Ä —Ä–∞–∑–º–µ—â—ë–Ω –Ω–∞ Bybit: "
                        f"exchange_order_id={exchange_order_id}, "
                        f"client_order_id={order_link_id}"
                    )

                    # –°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ –¥–ª—è –∏–¥–µ–º–ø–æ—Ç–µ–Ω—Ç–Ω–æ—Å—Ç–∏
                    await idempotency_service.save_operation_result(
                        operation="place_order",
                        params={"symbol": symbol, "side": side, "quantity": quantity},
                        result={
                            "exchange_order_id": exchange_order_id,
                            "client_order_id": order_link_id,
                            "timestamp": get_timestamp_ms()
                        },
                        ttl_minutes=60
                    )

                except Exception as order_error:
                    logger.error(
                        f"‚ùå –û–®–ò–ë–ö–ê —Ä–∞–∑–º–µ—â–µ–Ω–∏—è –æ—Ä–¥–µ—Ä–∞ –Ω–∞ Bybit: {order_error}"
                    )
                    self.stats["failed_orders"] += 1

                    await audit_repository.log(
                        action=AuditAction.POSITION_OPEN,
                        entity_type="Position",
                        entity_id="FAILED",
                        new_value={
                            "symbol": symbol,
                            "side": side,
                            "quantity": quantity,
                            "error": str(order_error)
                        },
                        reason=f"Failed to place order: {str(order_error)}",
                        success=False,
                        error_message=str(order_error)
                    )

                    return None

                # ==========================================
                # –®–ê–ì 2: –°–û–ó–î–ê–ù–ò–ï –ü–û–ó–ò–¶–ò–ò –í –ë–î
                # ==========================================
                logger.info(f"üíæ –°–æ–∑–¥–∞–Ω–∏–µ –ø–æ–∑–∏—Ü–∏–∏ –≤ –ë–î –ø–æ—Å–ª–µ —É—Å–ø–µ—à–Ω–æ–≥–æ —Ä–∞–∑–º–µ—â–µ–Ω–∏—è")

                order_side = OrderSide.BUY if side == "Buy" else OrderSide.SELL

                position = await position_repository.create(
                    symbol=symbol,
                    side=order_side,
                    quantity=quantity,
                    entry_price=entry_price,
                    stop_loss=stop_loss,
                    take_profit=take_profit,
                    entry_signal=entry_signal,
                    entry_market_data=entry_market_data,
                    entry_indicators=entry_indicators,
                    entry_reason=entry_reason or f"{side} position opened",
                    # –í–ê–ñ–ù–û: –°–æ—Ö—Ä–∞–Ω—è–µ–º exchange_order_id
                    metadata_json={
                        "exchange_order_id": exchange_order_id,
                        "client_order_id": client_order_id,
                        "order_placed_at": get_timestamp_ms()
                    }
                )

                position_id = str(position.id)

                logger.info(
                    f"‚úì –ü–æ–∑–∏—Ü–∏—è —Å–æ–∑–¥–∞–Ω–∞ –≤ –ë–î: {position_id} | "
                    f"–°—Ç–∞—Ç—É—Å: {position.status.value} | "
                    f"Exchange Order: {exchange_order_id}"
                )

                # ==========================================
                # –®–ê–ì 3-6: FSM, Risk Manager, Audit
                # ==========================================
                # ... –æ—Å—Ç–∞–ª—å–Ω–æ–π –∫–æ–¥ –±–µ–∑ –∏–∑–º–µ–Ω–µ–Ω–∏–π ...

                position_fsm = PositionStateMachine(
                    position_id=position_id,
                    initial_state=PositionStatus.OPENING
                )

                fsm_registry.register_position_fsm(position_id, position_fsm)
                position_fsm.confirm_open()  # type: ignore

                await position_repository.update_status(
                    position_id=position_id,
                    new_status=PositionStatus.OPEN
                )

                position_size_usdt = quantity * entry_price
                signal_type = SignalType.BUY if side == "Buy" else SignalType.SELL

                self.risk_manager.register_position_opened(
                    symbol=symbol,
                    side=signal_type,
                    size_usdt=position_size_usdt,
                    entry_price=entry_price,
                    leverage=10
                )

                await audit_repository.log(
                    action=AuditAction.POSITION_OPEN,
                    entity_type="Position",
                    entity_id=position_id,
                    new_value={
                        "symbol": symbol,
                        "side": side,
                        "quantity": quantity,
                        "entry_price": entry_price,
                        "stop_loss": stop_loss,
                        "take_profit": take_profit,
                        "exchange_order_id": exchange_order_id
                    },
                    reason=entry_reason or "Position opened",
                    success=True,
                    context={
                        "entry_signal": entry_signal,
                        "entry_market_data": entry_market_data,
                        "entry_indicators": entry_indicators
                    }
                )

                logger.info(
                    f"‚úì‚úì‚úì –ü–û–ó–ò–¶–ò–Ø –£–°–ü–ï–®–ù–û –û–¢–ö–†–´–¢–ê ‚úì‚úì‚úì\n"
                    f"  Position ID: {position_id}\n"
                    f"  Exchange Order ID: {exchange_order_id}\n"
                    f"  Symbol: {symbol}\n"
                    f"  Side: {side}\n"
                    f"  Entry Price: {entry_price}\n"
                    f"  Quantity: {quantity}\n"
                    f"  Size: {position_size_usdt:.2f} USDT"
                )

                return {
                    "position_id": position_id,
                    "exchange_order_id": exchange_order_id,
                    "client_order_id": client_order_id,
                    "status": "success"
                }

            except Exception as e:
                logger.error(f"‚ùå –ö—Ä–∏—Ç–∏—á–µ—Å–∫–∞—è –æ—à–∏–±–∫–∞ open_position: {e}")

                # –ï—Å–ª–∏ –ø–æ–∑–∏—Ü–∏—è —Å–æ–∑–¥–∞–Ω–∞ –≤ –ë–î, –Ω–æ —á—Ç–æ-—Ç–æ –ø–æ—à–ª–æ –Ω–µ —Ç–∞–∫ –¥–∞–ª–µ–µ - –æ—Ç–∫–∞—Ç—ã–≤–∞–µ–º
                if position_id:
                    try:
                        await position_repository.update_status(
                            position_id=position_id,
                            new_status=PositionStatus.FAILED
                        )
                        logger.warning(f"–ü–æ–∑–∏—Ü–∏—è {position_id} –ø–æ–º–µ—á–µ–Ω–∞ –∫–∞–∫ FAILED")
                    except:
                        pass

                raise ExecutionError(f"Failed to open position: {str(e)}")

    async def close_position(
        self,
        position_id: str,
        exit_price: float,
        exit_signal: Optional[dict] = None,
        exit_market_data: Optional[dict] = None,
        exit_indicators: Optional[dict] = None,
        exit_reason: str = "Position closed"
    ) -> Optional[dict]:
        """
        –ó–∞–∫—Ä—ã—Ç–∏–µ –ø–æ–∑–∏—Ü–∏–∏ —Å –≤–∞–ª–∏–¥–∞—Ü–∏–µ–π —á–µ—Ä–µ–∑ FSM.

        Args:
            position_id: ID –ø–æ–∑–∏—Ü–∏–∏ –¥–ª—è –∑–∞–∫—Ä—ã—Ç–∏—è
            exit_price: –¶–µ–Ω–∞ –≤—ã—Ö–æ–¥–∞
            exit_signal: –°–∏–≥–Ω–∞–ª –Ω–∞ –≤—ã—Ö–æ–¥
            exit_market_data: –†—ã–Ω–æ—á–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ –ø—Ä–∏ –≤—ã—Ö–æ–¥–µ
            exit_indicators: –ò–Ω–¥–∏–∫–∞—Ç–æ—Ä—ã –ø—Ä–∏ –≤—ã—Ö–æ–¥–µ
            exit_reason: –ü—Ä–∏—á–∏–Ω–∞ –∑–∞–∫—Ä—ã—Ç–∏—è

        Returns:
            Optional[dict]: –†–µ–∑—É–ª—å—Ç–∞—Ç —Å realized_pnl –∏–ª–∏ None –ø—Ä–∏ –æ—à–∏–±–∫–µ
        """
        with trace_operation("close_position", position_id=position_id):
            logger.info(f"‚Üí –ó–∞–∫—Ä—ã—Ç–∏–µ –ø–æ–∑–∏—Ü–∏–∏: {position_id} @ {exit_price}")

            try:
                # 1. –ü–û–õ–£–ß–ï–ù–ò–ï –ü–û–ó–ò–¶–ò–ò –ò–ó –ë–î
                position = await position_repository.get_by_id(position_id)

                if not position:
                    logger.error(f"–ü–æ–∑–∏—Ü–∏—è {position_id} –Ω–µ –Ω–∞–π–¥–µ–Ω–∞ –≤ –ë–î")
                    return None

                symbol = position.symbol

                # 2. –ü–û–õ–£–ß–ï–ù–ò–ï –ò–õ–ò –í–û–°–°–¢–ê–ù–û–í–õ–ï–ù–ò–ï FSM
                position_fsm = fsm_registry.get_position_fsm(position_id)

                if not position_fsm:
                    logger.warning(
                        f"FSM –Ω–µ –Ω–∞–π–¥–µ–Ω–∞ –¥–ª—è –ø–æ–∑–∏—Ü–∏–∏ {position_id}, "
                        f"–≤–æ—Å—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –∏–∑ –ë–î"
                    )

                    position_fsm = PositionStateMachine(
                        position_id=position_id,
                        initial_state=position.status
                    )

                    fsm_registry.register_position_fsm(position_id, position_fsm)

                    logger.info(
                        f"FSM –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∞ –¥–ª—è –ø–æ–∑–∏—Ü–∏–∏ {position_id} | "
                        f"–°—Ç–∞—Ç—É—Å: {position_fsm.current_status.value}"
                    )

                # 3. –í–ê–õ–ò–î–ê–¶–ò–Ø –í–û–ó–ú–û–ñ–ù–û–°–¢–ò –ó–ê–ö–†–´–¢–ò–Ø
                if not position_fsm.can_transition_to(PositionStatus.CLOSING):
                    logger.error(
                        f"–ù–µ–≤–æ–∑–º–æ–∂–Ω–æ –∑–∞–∫—Ä—ã—Ç—å –ø–æ–∑–∏—Ü–∏—é {position_id} | "
                        f"–¢–µ–∫—É—â–∏–π —Å—Ç–∞—Ç—É—Å: {position_fsm.current_status.value} | "
                        f"–î–æ—Å—Ç—É–ø–Ω—ã–µ –ø–µ—Ä–µ—Ö–æ–¥—ã: {position_fsm.get_available_transitions()}"
                    )
                    return None

                logger.debug(f"‚úì –í–∞–ª–∏–¥–∞—Ü–∏—è –∑–∞–∫—Ä—ã—Ç–∏—è –ø—Ä–æ—à–ª–∞ –¥–ª—è –ø–æ–∑–∏—Ü–∏–∏ {position_id}")

                # 4. –î–í–£–•–®–ê–ì–û–í–û–ï –ó–ê–ö–†–´–¢–ò–ï –ß–ï–†–ï–ó FSM
                # –¢—Ä–∏–≥–≥–µ—Ä—ã —Å–æ–∑–¥–∞—é—Ç—Å—è –¥–∏–Ω–∞–º–∏—á–µ—Å–∫–∏ –±–∏–±–ª–∏–æ—Ç–µ–∫–æ–π transitions

                # –®–∞–≥ 1: OPEN -> CLOSING
                position_fsm.start_close()  # type: ignore[attr-defined]

                await position_repository.update_status(
                    position_id=position_id,
                    new_status=PositionStatus.CLOSING
                )

                logger.info(
                    f"‚úì –ü–æ–∑–∏—Ü–∏—è –ø–µ—Ä–µ–≤–µ–¥–µ–Ω–∞ –≤ CLOSING: {position_id} | "
                    f"FSM —Å—Ç–∞—Ç—É—Å: {position_fsm.current_status.value}"
                )

                # –®–∞–≥ 2: CLOSING -> CLOSED
                position_fsm.confirm_close()  # type: ignore[attr-defined]

                await position_repository.update_status(
                    position_id=position_id,
                    new_status=PositionStatus.CLOSED,
                    exit_price=exit_price,
                    exit_signal=exit_signal,
                    exit_market_data=exit_market_data,
                    exit_indicators=exit_indicators,
                    exit_reason=exit_reason
                )

                logger.info(
                    f"‚úì –ü–æ–∑–∏—Ü–∏—è –ø–µ—Ä–µ–≤–µ–¥–µ–Ω–∞ –≤ CLOSED: {position_id} | "
                    f"FSM —Å—Ç–∞—Ç—É—Å: {position_fsm.current_status.value}"
                )

                # 5. –£–î–ê–õ–ï–ù–ò–ï FSM –ò–ó REGISTRY
                fsm_registry.unregister_position_fsm(position_id)

                logger.debug(f"‚úì FSM —É–¥–∞–ª–µ–Ω–∞ –∏–∑ Registry –¥–ª—è –ø–æ–∑–∏—Ü–∏–∏ {position_id}")

                # 6. –û–ë–ù–û–í–õ–ï–ù–ò–ï RISK MANAGER
                self.risk_manager.register_position_closed(position.symbol)

                logger.info(
                    f"‚úì –ü–æ–∑–∏—Ü–∏—è —É–¥–∞–ª–µ–Ω–∞ –∏–∑ Risk Manager: {position.symbol}"
                )

                # 7. –ü–û–õ–£–ß–ï–ù–ò–ï –û–ë–ù–û–í–õ–ï–ù–ù–û–ô –ü–û–ó–ò–¶–ò–ò –î–õ–Ø PNL
                updated_position = await position_repository.get_by_id(position_id)

                realized_pnl = updated_position.realized_pnl or 0.0
                duration = (
                    (updated_position.closed_at - updated_position.opened_at).total_seconds()
                    if updated_position.closed_at and updated_position.opened_at
                    else 0
                )

                # 8. AUDIT LOGGING
                await audit_repository.log(
                    action=AuditAction.POSITION_CLOSE,
                    entity_type="Position",
                    entity_id=position_id,
                    new_value={
                        "exit_price": exit_price,
                        "realized_pnl": realized_pnl
                    },
                    reason=exit_reason,
                    success=True,
                    context={
                        "exit_signal": exit_signal,
                        "exit_market_data": exit_market_data,
                        "exit_indicators": exit_indicators
                    }
                )
                # ============================================
                # –ù–û–í–´–ô –®–ê–ì: –û–ß–ò–°–¢–ö–ê –ò–°–¢–û–†–ò–ò –°–ò–ì–ù–ê–õ–û–í
                # ============================================
                from strategy.signal_deduplicator import signal_deduplicator

                signal_deduplicator.clear_symbol(symbol)
                logger.info(
                    f"{symbol} | –ò—Å—Ç–æ—Ä–∏—è —Å–∏–≥–Ω–∞–ª–æ–≤ –æ—á–∏—â–µ–Ω–∞ –ø–æ—Å–ª–µ –∑–∞–∫—Ä—ã—Ç–∏—è –ø–æ–∑–∏—Ü–∏–∏"
                )

                # 9. –í–û–ó–í–†–ê–¢ –†–ï–ó–£–õ–¨–¢–ê–¢–ê
                result = {
                    "position_id": position_id,
                    "status": PositionStatus.CLOSED.value,
                    "symbol": updated_position.symbol,
                    "exit_price": exit_price,
                    "realized_pnl": realized_pnl,
                    "duration_seconds": duration,
                    "closed_at": updated_position.closed_at.isoformat() if updated_position.closed_at else None
                }

                logger.info(
                    f"‚úì‚úì‚úì –ü–û–ó–ò–¶–ò–Ø –£–°–ü–ï–®–ù–û –ó–ê–ö–†–´–¢–ê ‚úì‚úì‚úì\n"
                    f"  Position ID: {position_id}\n"
                    f"  Symbol: {updated_position.symbol}\n"
                    f"  Exit Price: {exit_price}\n"
                    f"  Realized PnL: {realized_pnl:.2f} USDT\n"
                    f"  Duration: {duration:.0f}s"
                )



                return result

            except Exception as e:
                logger.error(
                    f"‚úó –û—à–∏–±–∫–∞ –∑–∞–∫—Ä—ã—Ç–∏—è –ø–æ–∑–∏—Ü–∏–∏ {position_id}: {e}",
                    exc_info=True
                )

                await audit_repository.log(
                    action=AuditAction.POSITION_CLOSE,
                    entity_type="Position",
                    entity_id=position_id,
                    success=False,
                    error_message=str(e),
                    reason=f"Failed to close position: {exit_reason}"
                )

                return None

    # ==================== –ü–†–ò–í–ê–¢–ù–´–ï –ú–ï–¢–û–î–´ ====================

    async def _process_queue(self):
        """–û–±—Ä–∞–±–æ—Ç–∫–∞ –æ—á–µ—Ä–µ–¥–∏ —Å–∏–≥–Ω–∞–ª–æ–≤."""
        logger.info("–ó–∞–ø—É—â–µ–Ω–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∞ –æ—á–µ—Ä–µ–¥–∏ –∏—Å–ø–æ–ª–Ω–µ–Ω–∏—è")

        while self.is_running:
            try:
                # –ü–æ–ª—É—á–∞–µ–º —Å–∏–≥–Ω–∞–ª –∏–∑ –æ—á–µ—Ä–µ–¥–∏ —Å —Ç–∞–π–º–∞—É—Ç–æ–º
                try:
                    signal = await asyncio.wait_for(
                        self.signal_queue.get(),
                        timeout=1.0
                    )
                except asyncio.TimeoutError:
                    continue

                # –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º —Å–∏–≥–Ω–∞–ª
                await self._execute_signal(signal)

            except Exception as e:
                logger.error(f"–û—à–∏–±–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏ –æ—á–µ—Ä–µ–¥–∏ –∏—Å–ø–æ–ª–Ω–µ–Ω–∏—è: {e}")
                await asyncio.sleep(1)

    async def _execute_signal(self, signal: TradingSignal):
        """
        –ò—Å–ø–æ–ª–Ω–µ–Ω–∏–µ —Ç–æ—Ä–≥–æ–≤–æ–≥–æ —Å–∏–≥–Ω–∞–ª–∞ —Å –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ–º open_position.

        ‚úÖ –ö–õ–Æ–ß–ï–í–û–ï –ò–ó–ú–ï–ù–ï–ù–ò–ï: –ò—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è open_position –≤–º–µ—Å—Ç–æ _place_order

        Args:
            signal: –¢–æ—Ä–≥–æ–≤—ã–π —Å–∏–≥–Ω–∞–ª
        """
        # ============================================
        # –®–ê–ì 0.0: –ü–†–û–í–ï–†–ö–ê –õ–ò–ú–ò–¢–ê –ü–û–ó–ò–¶–ò–ô (CIRCUIT BREAKER)
        # ============================================
        # –ö–†–ò–¢–ò–ß–ù–û: –ü—Ä–æ–≤–µ—Ä—è–µ–º –î–û –¥–µ–¥—É–ø–ª–∏–∫–∞—Ü–∏–∏, –î–û –±–∞–ª–∞–Ω—Å–∞, –î–û –≤—Å–µ–≥–æ!
        current_positions = self.risk_manager.metrics.open_positions_count
        max_positions = self.risk_manager.limits.max_open_positions

        if current_positions >= max_positions:
            logger.warning(
                f"üõë CIRCUIT BREAKER: –î–æ—Å—Ç–∏–≥–Ω—É—Ç –ª–∏–º–∏—Ç –ø–æ–∑–∏—Ü–∏–π {current_positions}/{max_positions}. "
                f"–û—Ç–∫—Ä—ã—Ç—ã–µ –ø–∞—Ä—ã: {list(self.risk_manager.open_positions.keys())}. "
                f"–°–∏–≥–Ω–∞–ª {signal.symbol} –æ—Ç–∫–ª–æ–Ω—ë–Ω –ë–ï–ó –æ–±—Ä–∞–±–æ—Ç–∫–∏."
            )
            self.stats["rejected_orders"] += 1
            return

        # –ü—Ä–æ–≤–µ—Ä–∫–∞: —É–∂–µ –µ—Å—Ç—å –ø–æ–∑–∏—Ü–∏—è –ø–æ —ç—Ç–æ–π –ø–∞—Ä–µ?
        if signal.symbol in self.risk_manager.open_positions:
            logger.warning(
                f"‚ö†Ô∏è CIRCUIT BREAKER: –ü–æ –ø–∞—Ä–µ {signal.symbol} —É–∂–µ –æ—Ç–∫—Ä—ã—Ç–∞ –ø–æ–∑–∏—Ü–∏—è. "
                f"–°–∏–≥–Ω–∞–ª –æ—Ç–∫–ª–æ–Ω—ë–Ω."
            )
            self.stats["rejected_orders"] += 1
            return

        logger.debug(
            f"{signal.symbol} | ‚úì –ü—Ä–æ–≤–µ—Ä–∫–∞ –ª–∏–º–∏—Ç–∞: {current_positions}/{max_positions} "
            f"(–ø–æ—Å–ª–µ –æ—Ç–∫—Ä—ã—Ç–∏—è –±—É–¥–µ—Ç {current_positions + 1}/{max_positions})"
        )

        # ==========================================
        # –®–ê–ì 0: –î–ï–î–£–ü–õ–ò–ö–ê–¶–ò–Ø –°–ò–ì–ù–ê–õ–ê
        # ==========================================
        should_process, block_reason = signal_deduplicator.should_process_signal(signal)

        if not should_process:
            logger.info(
                f"{signal.symbol} | ‚è≠Ô∏è –°–∏–≥–Ω–∞–ª –ø—Ä–æ–ø—É—â–µ–Ω (–¥—É–±–ª–∏–∫–∞—Ç): {block_reason}"
            )
            self.stats["rejected_orders"] += 1
            return

        logger.info(
            f"{signal.symbol} | –ò—Å–ø–æ–ª–Ω–µ–Ω–∏–µ —Å–∏–≥–Ω–∞–ª–∞: "
            f"{signal.signal_type.value} @ {signal.price:.8f}"
        )

        try:
            # 1. –°–¢–†–û–ì–ê–Ø –ü–†–û–í–ï–†–ö–ê –ë–ê–õ–ê–ù–°–ê
            # ‚úÖ –ö–†–ò–¢–ò–ß–ù–û: Fallback –Ω–µ–¥–æ–ø—É—Å—Ç–∏–º - —Ç–æ–ª—å–∫–æ —Ä–µ–∞–ª—å–Ω—ã–π –±–∞–ª–∞–Ω—Å
            available_balance = balance_tracker.get_current_balance()

            if available_balance is None:
                error_msg = (
                    f"–ö–†–ò–¢–ò–ß–ï–°–ö–ê–Ø –û–®–ò–ë–ö–ê: –ë–∞–ª–∞–Ω—Å –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω –¥–ª—è {signal.symbol}. "
                    f"–ù–µ–≤–æ–∑–º–æ–∂–Ω–æ –æ–ø—Ä–µ–¥–µ–ª–∏—Ç—å –¥–æ—Å—Ç—É–ø–Ω–æ—Å—Ç—å —Å—Ä–µ–¥—Å—Ç–≤ –¥–ª—è –æ—Ç–∫—Ä—ã—Ç–∏—è –ø–æ–∑–∏—Ü–∏–∏."
                )
                logger.error(error_msg)

                # –û—Ç–∫–ª–æ–Ω—è–µ–º —Å–∏–≥–Ω–∞–ª –∏–∑-–∑–∞ –Ω–µ–¥–æ—Å—Ç—É–ø–Ω–æ—Å—Ç–∏ –±–∞–ª–∞–Ω—Å–∞
                self.stats["rejected_orders"] += 1
                self._add_to_history(signal, "rejected", "Balance unavailable")

                # –£–≤–µ–¥–æ–º–ª—è–µ–º —á–µ—Ä–µ–∑ audit
                await audit_repository.log(
                    action=AuditAction.POSITION_OPEN,
                    entity_type="Signal",
                    entity_id=signal.symbol,
                    success=False,
                    error_message=error_msg,
                    reason="Balance check failed - balance unavailable"
                )

                return

            logger.debug(f"–î–æ—Å—Ç—É–ø–Ω—ã–π –±–∞–ª–∞–Ω—Å: ${available_balance:.2f} USDT")

            # 2. –†–ê–°–ß–ï–¢ –†–ê–ó–ú–ï–†–ê –ü–û–ó–ò–¶–ò–ò
            position_size_usdt = self.risk_manager.calculate_position_size(
                signal,
                available_balance
            )

            # 3. –í–ê–õ–ò–î–ê–¶–ò–Ø –°–ò–ì–ù–ê–õ–ê
            is_valid, rejection_reason = self.risk_manager.validate_signal(
                signal,
                position_size_usdt
            )

            if not is_valid:
                logger.warning(
                    f"{signal.symbol} | –°–∏–≥–Ω–∞–ª –æ—Ç–∫–ª–æ–Ω–µ–Ω: {rejection_reason}"
                )
                self.stats["rejected_orders"] += 1
                self._add_to_history(signal, "rejected", rejection_reason)
                return

            # 4. –û–¢–ö–†–´–¢–ò–ï –ü–û–ó–ò–¶–ò–ò
            # ‚úÖ –ö–õ–Æ–ß–ï–í–û–ï –ò–ó–ú–ï–ù–ï–ù–ò–ï: –ò—Å–ø–æ–ª—å–∑—É–µ–º open_position

            # –ö–æ–Ω–≤–µ—Ä—Ç–∏—Ä—É–µ–º —Ç–∏–ø —Å–∏–≥–Ω–∞–ª–∞ –≤ —Å—Ç–æ—Ä–æ–Ω—É
            side = "Buy" if signal.signal_type == SignalType.BUY else "Sell"

            # –†–∞—Å—Å—á–∏—Ç—ã–≤–∞–µ–º –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ
            quantity = position_size_usdt / signal.price
            quantity = round_quantity(quantity, decimals=6)

            # –†–∞—Å—Å—á–∏—Ç—ã–≤–∞–µ–º SL/TP
            if side == "Buy":
                stop_loss = signal.price * 0.98  # -2%
                take_profit = signal.price * 1.05  # +5%
            else:
                stop_loss = signal.price * 1.02  # +2%
                take_profit = signal.price * 0.95  # -5%

            # –û—Ç–∫—Ä—ã–≤–∞–µ–º –ø–æ–∑–∏—Ü–∏—é —á–µ—Ä–µ–∑ –Ω–æ–≤—ã–π –º–µ—Ç–æ–¥
            result = await self.open_position(
                symbol=signal.symbol,
                side=side,
                entry_price=signal.price,
                quantity=quantity,
                stop_loss=stop_loss,
                take_profit=take_profit,
                entry_signal={
                    "type": signal.signal_type.value,
                    "source": signal.source.value,
                    "strength": signal.strength.value,
                    "confidence": signal.confidence
                },
                entry_market_data={
                    "price": signal.price,
                    "timestamp": signal.timestamp
                },
                entry_indicators=signal.metadata.get("indicators", {}),
                entry_reason=signal.reason
            )

            if result:
                # –û–±–Ω–æ–≤–ª—è–µ–º —Å–∏–≥–Ω–∞–ª
                signal.executed = True
                signal.execution_price = signal.price
                signal.execution_timestamp = get_timestamp_ms()

                self.stats["executed_orders"] += 1
                self._add_to_history(signal, "executed", result["position_id"])

                logger.info(
                    f"{signal.symbol} | –ü–æ–∑–∏—Ü–∏—è —É—Å–ø–µ—à–Ω–æ –æ—Ç–∫—Ä—ã—Ç–∞: "
                    f"position_id={result['position_id']}"
                )
            else:
                self.stats["failed_orders"] += 1
                self._add_to_history(signal, "failed", "Failed to open position")
                logger.error(
                    f"{signal.symbol} | –û—à–∏–±–∫–∞ –æ—Ç–∫—Ä—ã—Ç–∏—è –ø–æ–∑–∏—Ü–∏–∏"
                )

        except Exception as e:
            self.stats["failed_orders"] += 1
            self._add_to_history(signal, "failed", str(e))
            logger.error(f"{signal.symbol} | –û—à–∏–±–∫–∞ –∏—Å–ø–æ–ª–Ω–µ–Ω–∏—è —Å–∏–≥–Ω–∞–ª–∞: {e}")
            raise ExecutionError(f"Failed to execute signal: {str(e)}")

    def _add_to_history(self, signal: TradingSignal, status: str, details: str):
        """
        –î–æ–±–∞–≤–ª–µ–Ω–∏–µ –∑–∞–ø–∏—Å–∏ –≤ –∏—Å—Ç–æ—Ä–∏—é –∏—Å–ø–æ–ª–Ω–µ–Ω–∏—è.

        Args:
            signal: –¢–æ—Ä–≥–æ–≤—ã–π —Å–∏–≥–Ω–∞–ª
            status: –°—Ç–∞—Ç—É—Å –∏—Å–ø–æ–ª–Ω–µ–Ω–∏—è
            details: –î–µ—Ç–∞–ª–∏
        """
        self.execution_history.append({
            "timestamp": get_timestamp_ms(),
            "symbol": signal.symbol,
            "signal_type": signal.signal_type.value,
            "price": signal.price,
            "status": status,
            "details": details
        })

    # ==================== –°–¢–ê–¢–ò–°–¢–ò–ö–ê ====================

    def get_execution_history(self, limit: Optional[int] = None) -> List[Dict]:
        """–ü–æ–ª—É—á–µ–Ω–∏–µ –∏—Å—Ç–æ—Ä–∏–∏ –∏—Å–ø–æ–ª–Ω–µ–Ω–∏—è."""
        history = list(self.execution_history)

        if limit:
            history = history[-limit:]

        return history

    def get_statistics(self) -> Dict:
        """–ü–æ–ª—É—á–µ–Ω–∏–µ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏ –∏—Å–ø–æ–ª–Ω–µ–Ω–∏—è."""
        return {
            **self.stats,
            "queue_size": self.signal_queue.qsize(),
            "success_rate": (
                (self.stats["executed_orders"] / self.stats["total_signals"] * 100)
                if self.stats["total_signals"] > 0 else 0
            ),
            "rejection_rate": (
                (self.stats["rejected_orders"] / self.stats["total_signals"] * 100)
                if self.stats["total_signals"] > 0 else 0
            ),
        }